Different scenarios: # granted prev is before next
        prev insertions:
                if prev has new lines:
                        next.sl&el += # of new lines in prev.text

                if prev.sl == next.el
                        next.sc = next.sc - prev.length after last \n

                if prev.el == next.el

                        next.ec = next.ec - prev.length after last \n

        prev selection changes (replace/deletion):
                # if next range inside prev range might need to be account for before everything else

                #ofNewLinesRemoved = prev.el - prev.sl
                netNewLineChange = #ofNewLinesInPrevText - #ofNewLinesRemoved

                next.*l += netNewLineChange          # this might need to be after below parts or diff obj

                if prev.text.contains('\n'):
                        if prev.sl == next.el
                                next.sc = (next.sc - prev.ec) + prev.length after last \n
                        if prev.el == next.el
                                next.ec = (next.ec - prev.ec) + prev.length after last \n
                else:
                        if prev.el == next.sl:
                                next.sc -= (prev.range.prevLineLength - prev.text.length)
                        if prev.el == next.el:
                                next.ec -= (prev.range.prevLineLength - prev.text.length)

                if prev range contains next:
                        next.* = after prev new value. commonly replaced characters must be accounted for



# if next range inside prev range at all, consider next to be AFTER prev and common deletion can be discounted
# def - simple insert is no range insert. ie sc 3 ec 3 same lines, can be longer than 1 char
# def - selection insert or del that is replacing already existing text

# note - all deletions are replacements (selection changes)

# Algo
# recall selection does not include strict pastes
if !p.selection:
    if p.insertion:
        next.sl&el += # of new lines in prev.text
        if prev on same line as next:
            next.sc&ec += prev.text.length
    elif deletion:
        next.sl&el -= # of new lines in prev.text       # this may all be wrong
        if prev on same line as next:
                    next.sc&ec -= prev.text.length
else
    # notes below

















# Selection notes

If prev.ec == next.sc
    then next.*c & *l need to be updated
else
    only next.*l gets updates





# Delete notes

# Delete single element (both del and <- work same way)
sc: 8
ec: 9
sl: 1
el: 1

# Delete range on same line
sc: 1
ec: 6
sl: 1
el: 1

# Delete range including one new line in middle
sc: 7
ec: 6
sl: 1
el: 2





