Different scenarios:
        prev insertions:
                if prev has new lines:
                    next.sl&el += # of new lines in prev.text

                if prev.el == next.sl
                        next.sc = next.sc - prev.length after last \n
                if prev.el == next.el       # this only necessary for selections. assuming simple insert. this is also
                                            # ran with above sc adjustment
                        next.ec = next.ec - prev.length after last \n
        prev deletions:
                if prev range contains next
                        shift next to start of prev and adjust next ends accordingly
        prev selection changes:




# Algo
# recall selection does not include strict pastes
if !p.selection:
    if p.insertion:
        next.sl&el += # of new lines in prev.text
        if prev on same line as next:
            next.sc&ec += prev.text.length
    elif deletion:
        next.sl&el -= # of new lines in prev.text       # this may all be wrong
        if prev on same line as next:
                    next.sc&ec -= prev.text.length
else
    # notes below

















# Selection notes

If prev.ec == next.sc
    then next.*c & *l need to be updated
else
    only next.*l gets updates





# Delete notes

# Delete single element (both del and <- work same way)
sc: 8
ec: 9
sl: 1
el: 1

# Delete range on same line
sc: 1
ec: 6
sl: 1
el: 1

# Delete range including one new line in middle
sc: 7
ec: 6
sl: 1
el: 2





